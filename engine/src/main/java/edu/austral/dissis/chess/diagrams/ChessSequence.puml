@startuml
' ChessGame
' Board
' WinCondition
' PieceMovement
' WinConditionValidator
' Check
' PiecePathValidator
' Piece
' BoardPosition
' Move = (BoardPosition from, BoardPosition to)
Client -> ChessGame: makeMove(move)
' Not valid move is caused by piece rules, out of board bounds move, piece to move == null, etc
ChessGame -> PreMovementValidator: getMoveValidity(move, game)
PreMovementValidator -> PreMovementRule: isValidRule(move, game)
alt all rules are valid
    PreMovementValidator -> ChessGame: continue execution
    else any invalid
    PreMovementValidator -> ChessGame: return INVALID_MOVE
    ChessGame -> Client: return GameResult(game, INVALID_MOVE)
end
ChessGame -> Piece: getPlay(move, board)
loop for pieceMovement in piece.pieceMovements:
    Piece -> PieceMovement: isValidMove(move, board)
    alt move is valid == true
        PieceMovement -> Piece: add(move)
    else move is not valid
        PieceMovement -> Piece: continue execution
    end
    PieceMovement -> Piece: return List<ChessMove>movesToExecute
end
Piece -> ChessGame: return movesToExecute

loop for move in movesToExecute:
    ChessGame -> MoveExecutor: executeMove(move, board, promoter)
    MoveExecutor -> Board: board.pieceAt(move.from())
    Board -> MoveExecutor: return pieceToMove

    MoveExecutor -> Board: board.pieceAt(move.to())
    Board -> MoveExecutor: return pieceToTake
    alt pieceToTake != null
            MoveExecutor -> Board: removePieceAt(move.to())
            Board -> MoveExecutor: return updatedBoard
            MoveExecutor -> Board: removePieceAt(move.from()).addPieceAt(move.to(), pieceToMove.hasMoved() ? pieceToMove.changeActivity(): pieceToMove)
            Board -> MoveExecutor: return updatedBoard
            MoveExecutor -> ChessGame: return Pair(updatedBoard, PIECE_TAKEN)
    else null
    MoveExecutor -> Board: removePieceAt(move.from()).addPieceAt(move.to(), pieceToMove.hasMoved() ? pieceToMove.changeActivity(): pieceToMove)
    Board->MoveExecutor: return updatedBoard
    MoveExecutor -> ChessGame: return Pair(updatedBoard, VALID_MOVE)
end
end
ChessGame -> WinConditionValidator: isGameWon(finalBoard)
loop for winCondition in WinConditionValidator:
WinConditionValidator -> WinCondition: isValidRule(finalBoard)
WinCondition -> WinConditionValidator: return result
alt result == true
    WinConditionValidator -> WinConditionValidator: set winner based on currentTurn (color)
    WinConditionValidator -> ChessGame: return winner
    ChessGame -> Client: return GameResult(finalGame, winner)
else result == false
    WinConditionValidator-> WinConditionValidator: continue execution
end
end
WinConditionValidator -> ChessGame: return result (false case, no winner, then result = VALID_MOVE or PIECE_TAKEN)
ChessGame -> Client: return GameResult(finalGame, validMoveResult)

@enduml